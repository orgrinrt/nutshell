#!/usr/bin/env bash
# =============================================================================
# nutshell/check - Main QA runner
# =============================================================================
# Runs QA checks on your shell scripts. Executes:
#   1. Built-in nutshell checks (if enabled)
#   2. Custom checks defined in nut.toml
#
# Usage:
#   ./lib/nutshell/check              # Run all checks
#   ./lib/nutshell/check --builtins   # Only built-in checks
#   ./lib/nutshell/check --help       # Show help
#
# Configuration (nut.toml):
#   [qa]
#   run_builtins = true
#   custom_checks = ["checks/my_check.sh"]
#
# =============================================================================

set -uo pipefail

# Bootstrap nutshell (this is an entry point script)
. "${BASH_SOURCE[0]%/*}/init"

# Load nutshell modules
use os log string validate toml fs

# Set quiet mode so individual checks don't output verbose details
# They should only output on failure, and even then, tersely
export NUTSHELL_CHECK_QUIET=1

# =============================================================================
# Configuration
# =============================================================================

# Find config file
_find_config() {
    local search_paths=(
        "${PWD}/nut.toml"
        "${PWD}/tests/nut.toml"
        "${PWD}/scripts/nut.toml"
    )
    
    # Check NUTSHELL_CONFIG env var first
    if [[ -n "${NUTSHELL_CONFIG:-}" ]] && [[ -f "$NUTSHELL_CONFIG" ]]; then
        echo "$NUTSHELL_CONFIG"
        return 0
    fi
    
    for path in "${search_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Fall back to nutshell's own config
    if [[ -f "${NUTSHELL_ROOT}/nut.toml" ]]; then
        echo "${NUTSHELL_ROOT}/nut.toml"
        return 0
    fi
    
    return 1
}

# Find repo root
_find_repo_root() {
    local dir="${PWD}"
    
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]] || [[ -f "$dir/nut.toml" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    
    echo "${PWD}"
}

CONFIG_FILE=""
REPO_ROOT=""

# =============================================================================
# Colors
# =============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

_setup_colors() {
    if [[ ! -t 1 ]] || [[ -n "${NO_COLOR:-}" ]]; then
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        BOLD=''
        NC=''
    fi
}

# =============================================================================
# Help
# =============================================================================

_show_help() {
    cat <<EOF
nutshell check - QA runner for shell scripts

Usage:
  check [options]

Options:
  --builtins      Run only built-in checks (ignore custom_checks)
  --custom-only   Run only custom checks (skip built-ins)
  --list          List available checks
  --config FILE   Use specific config file
  --help, -h      Show this help

Configuration:
  Reads from nut.toml in current directory (or NUTSHELL_CONFIG env var)

  [qa]
  run_builtins = true                    # Run built-in nutshell checks
  custom_checks = [                      # Additional check scripts
      "checks/my_check.sh",
      "scripts/qa/another.sh"
  ]

Built-in checks:
  - syntax             Bash syntax validation
  - file_size          File size limits
  - function_duplication  Detect copy-pasted functions
  - trivial_wrappers   Find unnecessary wrapper functions
  - no_cruft           Detect debug code, TODOs
  - public_api_docs    Validate API documentation
  - config_schema      Validate nut.toml against schema

EOF
}

_list_checks() {
    echo "Built-in checks:"
    for check in "${NUTSHELL_ROOT}"/examples/checks/check_*.sh; do
        [[ ! -f "$check" ]] && continue
        local name
        name="$(basename "$check" .sh)"
        name="${name#check_}"
        echo "  - $name"
    done
    
    if [[ -n "$CONFIG_FILE" ]] && [[ -f "$CONFIG_FILE" ]]; then
        local -a custom_checks=()
        if toml_has "$CONFIG_FILE" "qa.custom_checks"; then
            toml_array "$CONFIG_FILE" "qa.custom_checks" custom_checks
            if [[ ${#custom_checks[@]} -gt 0 ]]; then
                echo ""
                echo "Custom checks (from config):"
                for check in "${custom_checks[@]}"; do
                    echo "  - $check"
                done
            fi
        fi
    fi
}

# =============================================================================
# Check execution
# =============================================================================

TOTAL_CHECKS=0
PASSED_CHECKS=0
FAILED_CHECKS=0
WARNED_CHECKS=0

_run_check() {
    local check_script="$1"
    local check_name="$2"
    
    if [[ ! -f "$check_script" ]]; then
        echo -e "  ${YELLOW}⚠${NC} ${check_name} - script not found: $check_script"
        ((WARNED_CHECKS++))
        return
    fi
    
    if [[ ! -x "$check_script" ]]; then
        chmod +x "$check_script"
    fi
    
    ((TOTAL_CHECKS++))
    
    # Run the check
    local output
    local exit_code
    output=$("$check_script" 2>&1)
    exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        if echo "$output" | grep -q "⚠\|warning\|WARNING"; then
            echo -e "  ${YELLOW}⚠${NC} ${check_name}"
            ((WARNED_CHECKS++))
        else
            echo -e "  ${GREEN}✓${NC} ${check_name}"
            ((PASSED_CHECKS++))
        fi
    else
        echo -e "  ${RED}✗${NC} ${check_name}"
        ((FAILED_CHECKS++))
    fi
    
    # In quiet mode, we don't dump the full output - the tree summary is enough
    # Only show output if there was a hard failure (exit code != 0)
    # and even then, just show the essential failure lines
    if [[ $exit_code -ne 0 ]]; then
        # Extract just the failure lines (✗) and any actual errors
        echo "$output" | grep -E "^\s*(✗|FAIL|ERROR|\[FAIL\]|\[ERROR\])" | head -5 | sed 's/^/      /'
    fi
}

_run_builtin_checks() {
    echo ""
    echo -e "${BOLD}Built-in Checks${NC}"
    echo ""
    
    for check in "${NUTSHELL_ROOT}"/examples/checks/check_*.sh; do
        [[ ! -f "$check" ]] && continue
        local name
        name="$(basename "$check" .sh)"
        name="${name#check_}"
        _run_check "$check" "$name"
    done
}

_run_custom_checks() {
    local -a custom_checks=()
    
    if [[ -z "$CONFIG_FILE" ]] || [[ ! -f "$CONFIG_FILE" ]]; then
        return
    fi
    
    if ! toml_has "$CONFIG_FILE" "qa.custom_checks"; then
        return
    fi
    
    toml_array "$CONFIG_FILE" "qa.custom_checks" custom_checks
    
    if [[ ${#custom_checks[@]} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -e "${BOLD}Custom Checks${NC}"
    echo ""
    
    for check in "${custom_checks[@]}"; do
        local check_path
        if [[ "$check" == /* ]]; then
            check_path="$check"
        else
            check_path="${REPO_ROOT}/${check}"
        fi
        
        local name
        name="$(basename "$check" .sh)"
        _run_check "$check_path" "$name"
    done
}

_print_summary() {
    echo ""
    echo -e "${BOLD}────────────────────────────────────────${NC}"
    
    if [[ $FAILED_CHECKS -gt 0 ]]; then
        echo -e "${RED}${BOLD}FAILED${NC} - $FAILED_CHECKS of $TOTAL_CHECKS checks failed"
        return 1
    elif [[ $WARNED_CHECKS -gt 0 ]]; then
        echo -e "${YELLOW}${BOLD}PASSED WITH WARNINGS${NC} - $TOTAL_CHECKS checks ($WARNED_CHECKS warnings)"
        return 0
    else
        echo -e "${GREEN}${BOLD}PASSED${NC} - All $TOTAL_CHECKS checks passed"
        return 0
    fi
}

# =============================================================================
# Main
# =============================================================================

main() {
    _setup_colors
    
    local run_builtins=true
    local run_custom=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                _show_help
                exit 0
                ;;
            --builtins)
                run_custom=false
                shift
                ;;
            --custom-only)
                run_builtins=false
                shift
                ;;
            --list)
                CONFIG_FILE="$(_find_config)" || true
                _list_checks
                exit 0
                ;;
            --config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use --help for usage"
                exit 1
                ;;
        esac
    done
    
    # Find configuration
    if [[ -z "$CONFIG_FILE" ]]; then
        CONFIG_FILE="$(_find_config)" || true
    fi
    
    REPO_ROOT="$(_find_repo_root)"
    
    # Header
    echo ""
    echo -e "${BOLD}nutshell QA${NC}"
    if [[ -n "$CONFIG_FILE" ]]; then
        echo -e "${BLUE}Config: ${CONFIG_FILE}${NC}"
    else
        echo -e "${BLUE}Config: (defaults)${NC}"
    fi
    
    # Check if builtins should run
    if [[ "$run_builtins" == "true" ]]; then
        if [[ -n "$CONFIG_FILE" ]] && [[ -f "$CONFIG_FILE" ]]; then
            local cfg_run_builtins
            cfg_run_builtins=$(toml_get_or "$CONFIG_FILE" "qa.run_builtins" "true")
            if ! is_truthy "$cfg_run_builtins"; then
                run_builtins=false
            fi
        fi
    fi
    
    # Run checks
    [[ "$run_builtins" == "true" ]] && _run_builtin_checks
    [[ "$run_custom" == "true" ]] && _run_custom_checks
    
    # Summary
    _print_summary
}

main "$@"
